#!/usr/bin/perl -CA
use 5.018;
use warnings;
use utf8;
use List::Util qw( min max sum );
use open qw( :std :utf8 );
use experimental qw( lexical_subs );

our $VERSION = '1.05';

use Getopt::Long '2.33', qw( :config gnu_getopt );
my %opt;
GetOptions(\%opt,
	'color|c!',
	'C' => sub { $opt{color} = 0 },
	'field|f=s' => sub {
		eval {
			local $_ = $_[1];
			$opt{anchor} = /^[0-9]+$/ ? qr/(?:\S*\h+){$_}\K/ : qr/$_/;
		} or die $@ =~ s/(?: at .+)?$/ for option $_[0]/r;
	},
	'human-readable|H!',
	'interval|t:i',
	'trim|length|l=s' => sub {
		my ($optname, $optval) = @_;
		$optval =~ s/%$// and $opt{trimpct}++;
		$optval =~ m/^-?[0-9]+$/ or die(
			"Value \"$optval\" invalid for option $optname",
			" (number or percentage expected)\n"
		);
		$opt{trim} = $optval;
	},
	'value-length=i',
	'hidemin=i',
	'hidemax=i',
	'limit|L=s' => sub {
		my ($optname, $optval) = @_;
		$optval ||= 0;
		($opt{hidemin}, $opt{hidemax}) =
		$optval =~ m/\A (?: ([0-9]+)? - )? ([0-9]+)? \z/x or die(
			"Value \"$optval\" invalid for option limit",
			" (range expected)\n"
		);
	},
	'markers|m=s',
	'spark:s' => sub {
		$opt{spark} = [split //, $_[1] || '⎽▁▂▃▄▅▆▇█'];
	},
	'stat|s!',
	'unmodified|u!',
	'width|w=i',
	'usage|h' => sub {
		local $/;
		my $pod = readline *DATA;
		$pod =~ s/^=over\K/ 22/m;  # indent options list
		$pod =~ s/^=item \N*\n\n\N*\n\K(?:(?:^=over.*?^=back\n)?(?!=)\N*\n)*/\n/msg;

		require Pod::Usage;
		my $parser = Pod::Usage->new;
		$parser->select('SYNOPSIS', 'OPTIONS');
		$parser->output_string(\my $contents);
		$parser->parse_string_document($pod);

		$contents =~ s/\n(?=\n\h)//msg;  # strip space between items
		print $contents;
		exit;
	},
	'help|?'  => sub {
		require Pod::Usage;
		Pod::Usage::pod2usage(
			-exitval => 0, -perldocopt => '-oman', -verbose => 2,
		);
	},
) or exit 64;  # EX_USAGE

$opt{width} ||= $ENV{COLUMNS} || 80;
$opt{color} //= -t *STDOUT;  # enable on tty
$opt{trim}   *= $opt{width} / 100 if $opt{trimpct};
$opt{units}   = [split //, ' kMGTPEZYyzafpnμm'] if $opt{'human-readable'};
$opt{anchor} //= qr/\A/;
$opt{'value-length'} = 6 if $opt{units};
$opt{'value-length'} = 1 if $opt{unmodified};

my (@lines, @values, @order);

$SIG{ALRM} = sub {
	show_lines();
	alarm $opt{interval} if defined $opt{interval};
};

if (defined $opt{interval}) {
	$opt{interval} ||= 1;
	alarm $opt{interval};

	eval {
		require Tie::Array::Sorted;
		tie @order, 'Tie::Array::Sorted', sub { $_[1] <=> $_[0] };
	} or warn $@, "Expect slowdown with large datasets!\n";
}

$SIG{INT} = sub {
	$SIG{INT} = 'DEFAULT';  # reset for subsequent attempts
	'IGNORE' # continue after assumed eof
};

my $valmatch = qr/$opt{anchor} ( \h* -? [0-9]* \.? [0-9]+ (?: e[+-]?[0-9]+ )? |)/x;
while (readline) {
	s/\r?\n\z//;
	s/^\h*// unless $opt{unmodified};
	push @values, s/$valmatch/\n/ && $1;
	push @order, $1 if length $1;
	if (defined $opt{trim} and defined $1) {
		my $trimpos = abs $opt{trim};
		$trimpos -= length $1 if $opt{unmodified};
		if ($trimpos <= 1) {
			$_ = substr $_, 0, 2;
		}
		elsif (length > $trimpos) {
			substr($_, $trimpos - 1) = '…';
		}
	}
	push @lines, $_;
}

$SIG{INT} = 'DEFAULT';

sub color {
	$opt{color} and defined $_[0] or return '';
	return "\e[$_[0]m" if defined wantarray;
	$_ = color(@_) . $_ . color(0) if defined;
}

sub show_lines {

state $nr = $opt{hidemin} ? $opt{hidemin} - 1 : 0;
@lines and @lines > $nr or return;
@lines or return;
@lines > $nr or return unless $opt{hidemin};

@order = sort { $b <=> $a } @order unless tied @order;
my $maxval = ($opt{hidemax} ? max grep { length } @values[0 .. $opt{hidemax} - 1] : $order[0]) // 0;
my $minval = min $order[-1] // (), 0;
my $lenval = $opt{'value-length'} // max map { length } @order;
my $len    = defined $opt{trim} && $opt{trim} <= 0 ? -$opt{trim} + 1 :
	max map { length $values[$_] && length $lines[$_] }
		0 .. min $#lines, $opt{hidemax} || ();  # left padding
my $size   = ($maxval - $minval) &&
	($opt{width} - $lenval - $len) / ($maxval - $minval);  # bar multiplication

my @barmark;
if ($opt{markers} // 1 and $size > 0) {
	my sub orderpos { (($order[$_[0]] + $order[$_[0] + .5]) / 2 - $minval) * $size }
	$barmark[ (sum(@order) / @order - $minval) * $size ] = '=';  # average
	$barmark[ orderpos($#order * .31731) ] = '>';
	$barmark[ orderpos($#order * .68269) ] = '<';
	$barmark[ orderpos($#order / 2) ] = '+';  # mean
	$barmark[ -$minval * $size ] = '|' if $minval < 0;  # zero
	color(36) for @barmark;

	state $lastmax = $maxval;
	if ($maxval > $lastmax) {
		print ' ' x ($lenval + $len);
		printf color(90);
		printf '%-*s',
			($lastmax - $minval) * $size + .5,
			'-' x (($values[$nr - 1] - $minval) * $size);
		print color(92);
		say '+' x (($maxval - $lastmax - $minval) * $size + .5);
		print color(0);
		$lastmax = $maxval;
	}
}

@lines > $nr or return if $opt{hidemin};

sub sival {
	my $unit = int(log(abs $_[0] || 1) / log(10) - 3*($_[0] < 1) + 1e-15);
	my $float = $_[0] !~ /^0*[-0-9]{1,3}$/;
	sprintf('%3.*f%1s',
		$float && ($unit % 3) == ($unit < 0),  # tenths
		$_[0] / 1000 ** int($unit/3),   # number
		$#{$opt{units}} * 1.5 < abs $unit ? "e$unit" : $opt{units}->[$unit/3]
	);
}

while ($nr <= $#lines) {
	$nr >= $opt{hidemax} and last if defined $opt{hidemax};
	my $val = $values[$nr];

	if ($opt{spark}) {
		print $opt{spark}->[ ($val - $minval) / $maxval * $#{$opt{spark}} ];
		next;
	}

	if (length $val) {
		my $color = !$opt{color} ? undef :
			$val == $order[0] ? 32 : # max
			$val == $order[-1] ? 31 : # min
			90;
		$val = $opt{units} ? sival($val) : sprintf "%*s", $lenval, $val;
		color($color) for $val;
	}
	my $line = $lines[$nr] =~ s/\n/$val/r;
	printf '%-*s', $len + length($val), $line;
	print $barmark[$_] // '-' for 1 .. $size && (($values[$nr] || 0) - $minval) * $size + .5;
	say '';
}
continue {
	$nr++;
}
say '' if $opt{spark};

}
show_lines();

if ($opt{stat}) {
	if ($opt{hidemin} or $opt{hidemax}) {
		$opt{hidemin} ||= 1;
		$opt{hidemax} ||= @lines;
		printf '%s of ', sum(@values[$opt{hidemin} - 1 .. $opt{hidemax} - 1]) // 0;
	}
	if (@order) {
		my $total = sum @order;
		printf '%s total', color(1) . $total . color(0);
		printf ' in %d values', scalar @values;
		printf(' (%s min, %s avg, %s max)',
			color(31) . $order[-1] . color(0),
			color(36) . (sprintf '%*.*f', 0, 2, $total / @order) . color(0),
			color(32) . $order[0] . color(0),
		);
	}
	say '';
}

__END__
=encoding utf8

=head1 NAME

barcat - graph to visualize input values

=head1 SYNOPSIS

B<barcat> [<options>] [<input>]

=head1 DESCRIPTION

Visualizes relative sizes of values read from input (file(s) or STDIN).
Contents are concatenated similar to I<cat>,
but numbers are reformatted and a bar graph is appended to each line.

Don't worry, barcat does not drink and divide.
It can has various options for input and output (re)formatting,
but remains limited to one-dimensional charts.
For more complex graphing needs
you'll need a larger animal like I<gnuplot>.

=head1 OPTIONS

=over

=item -c, --[no-]color

Force colored output of values and bar markers.
Defaults on if output is a tty,
disabled otherwise such as when piped or redirected.

=item -f, --field=(<number>|<regexp>)

Compare values after a given number of whitespace separators,
or matching a regular expression.

Unspecified or I<-f0> means values are at the start of each line.
With I<-f1> the second word is taken instead.
A string can indicate the starting position of a value
(such as I<-f:> if preceded by colons),
or capture the numbers itself,
for example I<-f'(\d+)'> for the first digits anywhere.

=item -H, --human-readable

Format values using SI unit prefixes,
turning long numbers like I<12356789> into I<12.4M>.
Also changes an exponent I<1.602176634e-19> to I<160.2z>.
Short integers are aligned but kept without decimal point.

=item -t, --interval[=<seconds>]

Interval time to output partial progress.
An update can also be forced by sending a I<SIGALRM> alarm signal.

=item -l, --length=[-]<size>[%]

Trim line contents (between number and bars)
to a maximum number of characters.
The exceeding part is replaced by an abbreviation sign,
unless C<--length=0>.

Prepend a dash (i.e. make negative) to enforce padding
regardless of encountered contents.

=item -L, --limit=(<count>|<start>-[<end>])

Stop output after a number of lines.
All input is still counted and analyzed for statistics,
but disregarded for padding and bar size.

=item -m, --markers=

Statistical positions to indicate on bars.
Cannot be customized yet,
only disabled by providing an empty argument.

Any value enables all marker characters:

=over 2

=item B<=>

Average:
the sum of all values divided by the number of counted lines.

=item B<+>

Mean, median:
the middle value or average between middle values.

=item B<<>

Standard deviation left of the mean.
Only 16% of all values are lower.

=item B<< > >>

Standard deviation right of the mean.
The part between B<< <--> >> encompass all I<normal> results,
or 68% of all entries.

=back

=item -s, --stat

Total statistics after all data.

=item -u, --unmodified

Do not reformat values, keeping leading whitespace.
Keep original value alignment, which may be significant in some programs.

=item --value-length=<size>

Reserved space for numbers.

=item -w, --width=<columns>

Override the maximum number of columns to use.
Appended graphics will extend to fill up the entire screen.

=item -h, --usage

Overview of available options.

=item --help

Full documentation
rendered by perldoc.

=item --version

Version information.

=back

=head1 EXAMPLES

Draw a sine wave:

    seq 30 | awk '{print sin($1/10)}' | barcat

Compare file sizes (with human-readable numbers):

    du -d0 -b * | barcat -H

Memory usage of user processes with long names truncated:

    ps xo %mem,pid,cmd | barcat -l40

Monitor network latency from prefixed results:

    ping google.com | barcat -f'time=\K' -t

Commonly used after counting, for example users on the current server:

    users | sed 's/ /\n/g' | sort | uniq -c | barcat

Letter frequencies in text files:

    cat /usr/share/games/fortunes/*.u8 |
    perl -CS -nE 'say for grep length, split /\PL*/, uc' |
    sort | uniq -c | barcat

Number of HTTP requests per day:

    cat log/access.log | cut -d\  -f4 | cut -d: -f1 | uniq -c | barcat

Any kind of database query with counts, preserving returned alignment:

    echo 'SELECT count(*),schemaname FROM pg_tables GROUP BY 2' |
    psql -t | barcat -u

Earthquakes worldwide magnitude 1+ in the last 24 hours:

    https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/1.0_day.csv |
    column -tns, | graph -f4 -u -l80%

External datasets, like movies per year:

    curl https://github.com/prust/wikipedia-movie-data/raw/master/movies.json |
    perl -054 -nlE 'say if s/^"year"://' | uniq -c | barcat

But please get I<jq> to process JSON
and replace the manual selection by C<< jq '.[].year' >>.

Pokémon height comparison:

    curl https://github.com/Biuni/PokemonGO-Pokedex/raw/master/pokedex.json |
    jq -r '.pokemon[] | [.height,.num,.name] | join(" ")' | barcat

USD/EUR exchange rate from CSV provided by the ECB:

    curl https://sdw.ecb.europa.eu/export.do \
         -Gd 'node=SEARCHRESULTS&q=EXR.D.USD.EUR.SP00.A&exportType=csv' |
    grep '^[12]' | barcat -f',\K' --value-length=7

Total population history from the World Bank dataset (XML):
External datasets, like total population in XML from the World Bank:

    curl http://api.worldbank.org/v2/country/1W/indicator/SP.POP.TOTL |
    xmllint --xpath '//*[local-name()="date" or local-name()="value"]' - |
    sed -r 's,</wb:value>,\n,g; s,(<[^>]+>)+, ,g' | barcat -f1 -H

And of course various Git statistics, such commit count by year:

    git log --pretty=%ci | cut -b-4 | uniq -c | barcat

Or the top 3 most frequent authors with statistics over all:

    git shortlog -sn | barcat -L3 -s

Activity of the last days (substitute date C<-v-{}d> on BSD):

    ( git log --pretty=%ci --since=30day | cut -b-10
      seq 0 30 | xargs -i date +%F -d-{}day ) |
    sort | uniq -c | awk '$1--' | graph --spark

=head1 AUTHOR

Mischa POSLAWSKY <perl@shiar.org>

=head1 LICENSE

GPL3+.
