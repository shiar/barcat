#!/usr/bin/env perl
use 5.018;
use warnings;
use utf8;
use List::Util qw( min max sum );
use open qw( :std :utf8 );
use experimental qw( lexical_subs );

our $VERSION = '1.03';

use Getopt::Long '2.33', qw( :config gnu_getopt );
sub podexit {
	require Pod::Usage;
	Pod::Usage::pod2usage(-exitval => 0, -perldocopt => '-oman', @_);
}
my %opt;
GetOptions(\%opt,
	'color|c!',
	'C' => sub { $opt{color} = 0 },
	'field|f=s' => sub {
		eval {
			local $_ = $_[1];
			$opt{anchor} = /^[0-9]+$/ ? qr/(?:\S*\h+){$_}\K/ : qr/$_/;
		} or die $@ =~ s/(?: at .+)?$/ for option $_[0]/r;
	},
	'human-readable|H!',
	'interval|t:i',
	'trim|length|l=s' => sub {
		my ($optname, $optval) = @_;
		$optval =~ s/%$// and $opt{trimpct}++;
		$optval =~ m/^-?[0-9]+$/ or die(
			"Value \"$optval\" invalid for option $optname",
			" (number or percentage expected)\n"
		);
		$opt{trim} = $optval;
	},
	'value-length=i',
	'hidemin=i',
	'hidemax=i',
	'limit|L=s' => sub {
		my ($optname, $optval) = @_;
		$optval ||= 0;
		($opt{hidemin}, $opt{hidemax}) =
		$optval =~ m/\A (?: ([0-9]+)? - )? ([0-9]+)? \z/x or die(
			"Value \"$optval\" invalid for option limit",
			" (range expected)\n"
		);
	},
	'markers|m=s',
	'stat|s!',
	'unmodified|u!',
	'width|w=i',
	'usage|h' => sub { podexit() },
	'help'    => sub { podexit(-verbose => 2) },
) or exit 64;  # EX_USAGE

$opt{width} ||= $ENV{COLUMNS} || 80;
$opt{color} //= -t *STDOUT;  # enable on tty
$opt{trim}   *= $opt{width} / 100 if $opt{trimpct};
$opt{units}   = [split //, ' kMGTPEZYyzafpnμm'] if $opt{'human-readable'};
$opt{anchor} //= qr/\A/;
$opt{'value-length'} = 6 if $opt{units};

if (defined $opt{interval}) {
	$opt{interval} ||= 1;
	$SIG{ALRM} = sub {
		show_lines();
		alarm $opt{interval};
	};
	alarm $opt{interval};
}

$SIG{INT} = 'IGNORE';  # continue after assumed eof

my (@lines, @values);
my $valmatch = qr/$opt{anchor} ( \h* -? [0-9]* \.? [0-9]+ (?: e[+-]?[0-9]+ )? |)/x;
while (readline) {
	s/\r?\n\z//;
	s/^\h*// unless $opt{unmodified};
	push @values, s/$valmatch/\n/ && $1;
	if (defined $opt{trim}) {
		my $trimpos = abs $opt{trim};
		if ($trimpos <= 1) {
			$_ = substr $_, 0, 1;
		}
		elsif (length > $trimpos) {
			substr($_, $trimpos - 1) = '…';
		}
	}
	push @lines, $_;
}

$SIG{INT} = 'DEFAULT';

my @order;

sub show_lines {

state $nr = $opt{hidemin} ? $opt{hidemin} - 1 : 0;
@lines and @lines > $nr or return;
@lines or return;
@lines > $nr or return unless $opt{hidemin};

@order  = sort { $b <=> $a } grep { length } @values;
my $maxval = ($opt{hidemax} ? max grep { length } @values[0 .. $opt{hidemax} - 1] : $order[0]) // 0;
my $minval = min $order[-1] // (), 0;
my $lenval = $opt{'value-length'} // max map { length } @order;
my $len    = defined $opt{trim} && $opt{trim} <= 0 ? -$opt{trim} + 1 :
	max map { length $values[$_] && length $lines[$_] }
		0 .. min $#lines, $opt{hidemax} || ();  # left padding
my $size   = ($maxval - $minval) &&
	($opt{width} - $lenval - $len) / ($maxval - $minval);  # bar multiplication

my @barmark;
if ($opt{markers} // 1 and $size > 0) {
	my sub orderpos { (($order[$_[0]] + $order[$_[0] + .5]) / 2 - $minval) * $size }
	$barmark[ (sum(@order) / @order - $minval) * $size ] = '=';  # average
	$barmark[ orderpos($#order * .31731) ] = '>';
	$barmark[ orderpos($#order * .68269) ] = '<';
	$barmark[ orderpos($#order / 2) ] = '+';  # mean
	$barmark[ -$minval * $size ] = '|' if $minval < 0;  # zero
	defined and $opt{color} and $_ = "\e[36m$_\e[0m" for @barmark;

	state $lastmax = $maxval;
	if ($maxval > $lastmax) {
		print ' ' x ($lenval + $len);
		printf "\e[90m" if $opt{color};
		printf '%-*s',
			($lastmax - $minval) * $size + .5,
			'-' x (($values[$nr - 1] - $minval) * $size);
		print "\e[92m" if $opt{color};
		say '+' x (($maxval - $lastmax - $minval) * $size + .5);
		print "\e[0m" if $opt{color};
		$lastmax = $maxval;
	}
}

@lines > $nr or return if $opt{hidemin};

sub sival {
	my $unit = int(log($_[0]) / log(1000) - ($_[0] < 1));
	my $float = $_[0] !~ /^ (?: 0*\.)? [0-9]{1,3} $/x;
	sprintf('%*.*f%*s',
		$float ? 5 : 3, $float,  # length and tenths
		$_[0] / 1000 ** $unit,   # number
		$float ? 0 : 3,          # unit size
		$#{$opt{units}} >> 1 < abs $unit ? "e$unit" : $opt{units}->[$unit]
	);
}

while ($nr <= $#lines) {
	$nr >= $opt{hidemax} and last if defined $opt{hidemax};
	my $val = $values[$nr];
	if (length $val) {
		my $color = !$opt{color} ? 0 :
			$val == $order[0] ? 32 : # max
			$val == $order[-1] ? 31 : # min
			90;
		$val = $opt{units} ? sival($val) : sprintf "%*s", $lenval, $val;
		$val = "\e[${color}m$val\e[0m" if $color;
	}
	my $line = $lines[$nr] =~ s/\n/$val/r;
	printf '%-*s', $len + length($val), $line;
	print $barmark[$_] // '-' for 1 .. $size && (($values[$nr] || 0) - $minval) * $size + .5;
	say '';

	$nr++;
}

}
show_lines();

if ($opt{stat}) {
	my $total = sum @order;
	printf '%s total', $total;
	printf ' in %d values', scalar @values;
	printf ' (%s min, %*.*f avg, %s max)',
		$order[-1], 0, 2, $total / @order, $order[0];
	say '';
}

__END__

=head1 NAME

barcat - graph to visualize input values

=head1 SYNOPSIS

B<barcat> [<options>] [<input>]

=head1 DESCRIPTION

Visualizes relative sizes of values read from input (file(s) or STDIN).
Contents are concatenated similar to I<cat>,
but numbers are reformatted and a bar graph is appended to each line.

=head1 OPTIONS

=over

=item -c, --[no-]color

Force colored output of values and bar markers.
Defaults on if output is a tty,
disabled otherwise such as when piped or redirected.

=item -f, --field=(<number>|<regexp>)

Compare values after a given number of whitespace separators,
or matching a regular expression.

Unspecified or I<-f0> means values are at the start of each line.
With I<-f1> the second word is taken instead.
A string can indicate the starting position of a value
(such as I<-f:> if preceded by colons),
or capture the numbers itself,
for example I<-f'(\d+)'> for the first digits anywhere.

=item -H, --human-readable

Format values using SI unit prefixes,
turning long numbers like I<12356789> into I<12.4M>.
Also changes an exponent I<1.602176634e-19> to I<160.2z>.
Short integers are aligned but kept without decimal point.

=item -t, --interval[=<seconds>]

Interval time to output partial progress.

=item -l, --length=[-]<size>[%]

Trim line contents (between number and bars)
to a maximum number of characters.
The exceeding part is replaced by an abbreviation sign,
unless C<--length=0>.

Prepend a dash (i.e. make negative) to enforce padding
regardless of encountered contents.

=item -L, --limit=(<count>|<start>-[<end>])

Stop output after a number of lines.
All input is still counted and analyzed for statistics,
but disregarded for padding and bar size.

=item -m, --markers=

Statistical positions to indicate on bars.
Cannot be customized yet,
only disabled by providing an empty argument.

Any value enables all marker characters:

=over 2

=item B<=>

Average:
the sum of all values divided by the number of counted lines.

=item B<+>

Mean, median:
the middle value or average between middle values.

=item B<<>

Standard deviation left of the mean.
Only 16% of all values are lower.

=item B<< > >>

Standard deviation right of the mean.
The part between B<< <--> >> encompass all I<normal> results,
or 68% of all entries.

=back

=item -s, --stat

Total statistics after all data.

=item -u, --unmodified

Do not strip leading whitespace.
Keep original value alignment, which may be significant in some programs.

=item --value-length=<size>

Reserved space for numbers.

=item -w, --width=<columns>

Override the maximum number of columns to use.
Appended graphics will extend to fill up the entire screen.

=back

=head1 EXAMPLES

Commonly used after counting, such as users on the current server:

    users | sed 's/ /\n/g' | sort | uniq -c | barcat

Letter frequencies in text files:

    cat /usr/share/games/fortunes/*.u8 |
    perl -CO -nE 'say for grep length, split /\PL*/, uc' |
    sort | uniq -c | barcat

Memory usage of user processes:

    ps xo %mem,pid,cmd | barcat -l40

Sizes (in megabytes) of all root files and directories:

    du -d0 -m * | barcat

Number of HTTP requests per day:

    cat log/access.log | cut -d\  -f4 | cut -d: -f1 | uniq -c | barcat

Any kind of database query with leading counts:

    echo 'SELECT count(*),schemaname FROM pg_tables GROUP BY 2' |
    psql -t | barcat -u

Exchange rate USD/EUR history from CSV download provided by ECB:

    curl https://sdw.ecb.europa.eu/export.do \
         -Gd 'node=SEARCHRESULTS&q=EXR.D.USD.EUR.SP00.A&exportType=csv' |
    grep '^[12]' | barcat -f',\K' --value-length=7

Total population history from the World Bank dataset (XML):

    curl http://api.worldbank.org/v2/country/1W/indicator/SP.POP.TOTL |
    xmllint --xpath '//*[local-name()="date" or local-name()="value"]' - |
    sed -r 's,</wb:value>,\n,g; s,(<[^>]+>)+, ,g' | barcat -f1 -H

Movies per year from prepared JSON data:

    curl https://github.com/prust/wikipedia-movie-data/raw/master/movies.json |
    jq '.[].year' | uniq -c | barcat

Pokémon height comparison:

	curl https://github.com/Biuni/PokemonGO-Pokedex/raw/master/pokedex.json |
	jq -r '.pokemon[] | [.height,.num,.name] | join(" ")' | barcat

Git statistics, such commit count by year:

    git log --pretty=%ci | cut -b-4 | uniq -c | barcat

Or the top 3 most frequent authors with statistics over all:

    git shortlog -sn | barcat -L3 -s

Latency history:

    ping google.com | barcat -f'time=\K' -t

=head1 AUTHOR

Mischa POSLAWSKY <perl@shiar.org>

=head1 LICENSE

GPL3+.
