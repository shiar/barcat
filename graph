#!/usr/bin/env perl
use 5.014;
use warnings;
use utf8;
use List::Util qw( min max sum );
use open qw( :std :utf8 );

our $VERSION = '1.02';

use Getopt::Long '2.33', qw( :config gnu_getopt );
sub podexit {
	require Pod::Usage;
	Pod::Usage::pod2usage(-exitval => 0, -perldocopt => '-oman', @_);
}
GetOptions(\my %opt,
	'color|c!',
	'follow|f:i',
	'trim|length|l=i',
	'markers|m=s',
	'unclean|u!',
	'width|w=i',
	'usage|h' => sub { podexit() },
	'help'    => sub { podexit(-verbose => 2) },
) or exit 64;  # EX_USAGE

$opt{width} ||= $ENV{COLUMNS} || 80;
$opt{color} //= -t *STDOUT;  # enable on tty

if (defined $opt{follow}) {
	$opt{follow} ||= 1;
	$SIG{ALRM} = sub {
		show_lines();
		alarm $opt{follow};
	};
	alarm $opt{follow};
}

$SIG{INT} = 'IGNORE';  # continue after assumed eof

my (@lines, @values);
while (readline) {
	chomp;
	s/^\h*// unless $opt{unclean};
	push @values, s/^ ( \h* -? [0-9]* \.? [0-9]+ |)//x && $1;
	if (defined $opt{trim}) {
		my $trimpos = abs $opt{trim};
		if ($trimpos <= 1) {
			$_ = substr $_, 0, 1;
		}
		elsif (length > $trimpos) {
			substr($_, $trimpos - 1) = 'â€¦';
		}
	}
	push @lines, $_;
}
@lines or exit;

$SIG{INT} = 'DEFAULT';

sub show_lines {

state $nr = 0;

my @order  = sort { $b <=> $a } grep { length } @values;
my $maxval = $order[0];
my $minval = min $order[-1], 0;
my $lenval = max map { length } @order;
my $len    = defined $opt{trim} && $opt{trim} <= 0 ? -$opt{trim} + 1 :
	1 + max map { length } @lines;  # left padding
my $size   = ($maxval - $minval) &&
	($opt{width} - $lenval - $len) / ($maxval - $minval);  # bar multiplication

my @barmark;
if ($opt{markers} // 1 and $size > 0) {
	my sub orderpos { (($order[$_[0]] + $order[$_[0] + .5]) / 2 - $minval) * $size }
	$barmark[ (sum(@order) / @order - $minval) * $size ] = '=';  # average
	$barmark[ orderpos($#order * .31731) ] = '>';
	$barmark[ orderpos($#order * .68269) ] = '<';
	$barmark[ orderpos($#order / 2) ] = '+';  # mean
	$barmark[ -$minval * $size ] = '|' if $minval < 0;  # zero
	defined and $opt{color} and $_ = "\e[36m$_\e[0m" for @barmark;

	state $lastmax = $maxval;
	if ($maxval > $lastmax) {
		print ' ' x ($lenval + $len);
		printf "\e[90m" if $opt{color};
		printf '%-*s',
			($lastmax - $minval) * $size + .5,
			'-' x (($values[$nr - 1] - $minval) * $size);
		print "\e[92m" if $opt{color};
		say '+' x (($maxval - $lastmax - $minval) * $size + .5);
		print "\e[0m" if $opt{color};
		$lastmax = $maxval;
	}
}

while ($nr <= $#lines) {
	my $val = $values[$nr];
	if (length $val) {
		my $color = !$opt{color} ? 0 :
			$val == $order[0] ? 32 : # max
			$val == $order[-1] ? 31 : # min
			90;
		printf "\e[%sm", $color if $color;
		printf "%*s", $lenval, $val;
		print "\e[0m" if $color;
	}
	printf '%-*s', $len, $lines[$nr];
	print $barmark[$_] // '-' for 1 .. $size && (($val || 0) - $minval) * $size;
	say '';
	$nr++;
}

}
show_lines();

__END__

=head1 NAME

graph - append bar chart to input numbers

=head1 SYNOPSIS

B<graph> [<options>] [<input>]

=head1 DESCRIPTION

Each line starting with a number is given a bar to visualise relative sizes.

=head1 OPTIONS

=over

=item -c, --[no-]color

Force colored output of values and bar markers.
Defaults on if output is a tty,
disabled otherwise such as when piped or redirected.

=item -f, --follow[=<seconds>]

Interval to output partial progress.

=item -l, --length=[-]<size>

Trim line contents (between number and bars)
to a maximum number of characters.
The exceeding part is replaced by an abbreviation sign,
unless C<--length=0>.

Prepend a dash (i.e. make negative) to enforce padding
regardless of encountered contents.

=item -m, --markers=

Statistical positions to indicate on bars.
Cannot be customized yet,
only disabled by providing an empty argument.

Any value enables all marker characters:

=over 2

=item B<=>

Average:
the sum of all values divided by the number of counted lines.

=item B<+>

Mean, median:
the middle value or average between middle values.

=item B<<>

Standard deviation left of the mean.
Only 16% of all values are lower.

=item B<< > >>

Standard deviation right of the mean.
The part between B<< <--> >> encompass all I<normal> results,
or 68% of all entries.

=back

=item -u, --unclean

=item -w, --width=<columns>

Override the maximum number of columns to use.
Appended graphics will extend to fill up the entire screen.

=back

=head1 EXAMPLES

Commonly used after counting, such as users on the current server:

    users | sed 's/ /\n/g' | sort | uniq -c | graph

Letter frequencies in text files:

    cat /usr/share/games/fortunes/*.u8 |
    perl -CO -nE 'say for grep length, split /\PL*/, uc' |
    sort | uniq -c | graph

Memory usage of user processes:

    ps xo %mem,pid,cmd | graph -l40

Sizes (in megabytes) of all root files and directories:

    du -d0 -m * | graph

Number of HTTP requests per day:

    cat log/access.log | cut -d\  -f4 | cut -d: -f1 | uniq -c | graph

Any kind of database query with leading counts:

    echo 'SELECT count(*),schemaname FROM pg_tables GROUP BY 2' |
    psql -t | graph -u

Git statistics, such commit count by year:

    git log --pretty=%ci | cut -b-4 | uniq -c | graph

Or the most frequent authors:

    git shortlog -sn | graph | head -3

Latency history:

    ping google.com |
    perl -pe '$|=1; print s/ time=(.*)// ? "$1 for " : "> "' | graph -f

=head1 AUTHOR

Mischa POSLAWSKY <perl@shiar.org>

=head1 LICENSE

GPL3+.
